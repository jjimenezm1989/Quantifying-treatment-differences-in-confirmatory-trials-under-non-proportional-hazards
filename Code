library(survival)
library(data.table)
library(survRM2)
library(survMisc)
library(gsDesign)
library(PwrGSD)

options(max.print=10000)

nphsim <- function(nsim, lambdaC = NULL,lambdaE = NULL,intervals = NULL,ssC = NULL,ssE = NULL, E=NULL, gamma = NULL,etaC = NULL, etaE = NULL){
  
  tC <- rpwexp(ssC*nsim, rate = lambdaC, intervals = intervals)
  tE <- rpwexp(ssE*nsim, rate = lambdaE, intervals = intervals)
  
  xC<-data.table(sim=c(1:nsim),t=tC,treatment='control')
  xE<-data.table(sim=c(1:nsim),t=tE,treatment='experimental')
  
  #Add lost to follow up (ltfu)
  
  xC[,ltfuT:=rpwexp(ssC*nsim, rate = etaC+1e-8, intervals = intervals)]
  xE[,ltfuT:=rpwexp(ssE*nsim, rate = etaE+1e-8, intervals = intervals)]  
  
  x <- rbind(xC,xE)
  
  ## adding LTFU
  
  xC[,ltfuT:=rpwexp(ssC*nsim, rate = etaC+1e-8, intervals = intervals)]
  xE[,ltfuT:=rpwexp(ssE*nsim, rate = etaE+1e-8, intervals = intervals)]
  
  x <- rbind(xC,xE)
  x[,t_ltfu:=ifelse(t>ltfuT, ltfuT, t)]
  x[,cnsr_ltfu:=ifelse(t>ltfuT, 1, 0)]
  
  #Setting censoring threshold after E events
  
  x[,enterT:=rpois(N,gamma)]
  x[,ct:=enterT+t_ltfu]
  aux = x[order(x$ct),]
  aux2 = aux[which(aux$cnsr_ltfu == 0),] #To set the event related censoring threshold, we keep only those not censored due to ltfu
  aux3 = as.data.frame(aux2$ct)
  
  if(nrow(aux3) < E){
    censoring_time = tail(aux3,n=1)
  }else{
    censoring_time = aux3[E,]
  }
  
  x[,censoringTheshold := censoring_time]
  x[,enrolled := ifelse(enterT < censoringTheshold,1,0)]
  x[,survival := ifelse(ct > censoringTheshold, censoringTheshold - enterT, t_ltfu)]
  x[,cnsr := ifelse(ct > censoringTheshold | cnsr_ltfu == 1, 1, 0)]
  
  x[,c("t","ltfuT","enrolled"):=NULL]  ## remove intermediate variables
  
  #Log-rank test
  
  surv = x$survival
  cnsr = x$cnsr
  trt = x$treatment
  lr <- survdiff(Surv(surv, 1-cnsr) ~ trt)
  cox <- coxph(Surv(surv, 1-cnsr) ~ trt)
  csp <- pchisq(lr$chisq, length(unique(trt)) - 1, lower.tail = FALSE)
  
  pval_lr = ifelse((lr$obs[2] - lr$exp[2])<=0, csp/2, 1-csp/2)
  
  #Weighted log-rank test
  
  pval_wlr = wlr.Stat(surv, cnsr, trt, stra = NULL, fparam=list(rho=0, gamma=1))
  
  #RMST
  
  auxc1 = x[which(x$treatment == "control"),]
  auxc2 = auxc1[which(auxc1$cnsr == 0),]
  auxc3 = max(auxc2$survival)
  auxe1 = x[which(x$treatment == "experimental"),]
  auxe2 = auxe1[which(auxe1$cnsr == 0),]
  auxe3 = max(auxe2$survival)
  t_star_event = min(auxc3,auxe3)
  
  
  auxc1 = x[which(x$treatment == "control"),]
  auxc2 = max(auxc1$survival)
  auxe1 = x[which(x$treatment == "experimental"),]
  auxe2 = max(auxe1$survival)
  t_star_observed = min(auxc2,auxe2)
  
  pval_rmst_event = rmst.Stat(surv, cnsr, trt, stra = NULL, fparam = t_star_event)
  pval_rmst_observed = rmst.Stat(surv, cnsr, trt, stra = NULL, fparam = t_star_observed)
  
  
  y<-list(pval_lr = pval_lr,
          pval_wlr = pval_wlr,
          pval_rmst_event = pval_rmst_event,
          pval_rmst_observed = pval_rmst_observed,
          minimax_event = t_star_event,
          minimax_observed = t_star_observed,
          cnsr_threshold = aux3[E,],
          data = x)
  
  return(y)
}
rpwexp <- function(n, rate=1, intervals=NULL, cumulative=FALSE){
  if(is.null(intervals)){
    if (cumulative){return(cumsum(rexp(n,rate[1])))}else
      return(rexp(n,rate[1]))}
  k <- length(rate)
  if (k==1){
    if(cumulative){return(cumsum(rexp(n,rate)))}else
      return(rexp(n,rate))
  }
  if (length(intervals) < k-1) stop("length(intervals) must be at least length(rate) - 1")
  tx <- 0
  j <- 1
  times <- array(0,n)
  timex <- cumsum(intervals)
  indx <- array(TRUE,n)
  for(i in 1:k){
    nindx <- sum(indx)
    if (nindx==0) break
    increment <- rexp(nindx,rate[i])
    if (cumulative) times[indx] <- tx + cumsum(increment)
    else times[indx] <- tx + increment
    if (i<k){
      tx <- timex[i]
      indx <- (times > timex[i])
    }
  }
  return(times)
}
rmst.Stat <- function(survival, cnsr, trt, stra = NULL, fparam = NULL) {
  idx = trt == "experimental"
  tt = survival[idx]
  tau0max = max(tt)
  idx = trt == "control"
  tt = survival[idx]
  tau1max = max(tt)
  tau_max = min(tau0max, tau1max)
  tau <- ifelse(tau_max < fparam, tau_max, fparam)
  a <- rmst2(time = survival, status = 1 - cnsr, arm = (trt == "experimental"), tau = tau, alpha = 0.025)
  b <- a$unadjusted.result
  pval <- ifelse((b[1, 1])>=0, b[1, 4]/2, 1 - b[1, 4]/2)
  y <- list(pval = pval, tau = tau, est = b[1, 1], estlb = b[1, 2], estub = b[1, 3])
  return(y)
}
test.lr <- function(surv, cnsr, trt, stra = NULL,fparam=NULL) {
  ## logrank test p-value
  if (is.null(stra)) {
    lr <- survdiff(Surv(surv, 1 - cnsr) ~ trt)
    cox <- coxph(Surv(surv, 1 - cnsr) ~ trt)
  } else {
    lr <- survdiff(Surv(surv, 1 - cnsr) ~ trt + strata(stra))
    cox <- coxph(Surv(surv, 1 - cnsr) ~ trt + strata(stra))
  }
  ## lr$obs[2] - lr$exp[2]: experimental arm observed number of events minus expected (<0 means experimental arm is better)
  csp <- pchisq(lr$chisq, length(unique(trt)) - 1, lower.tail = FALSE)
  pval <- ifelse((lr$obs[2] - lr$exp[2])<=0, csp/2, 1-csp/2)
  y <- list(pval = pval, z = sign(lr$obs[2] - lr$exp[2]) * sqrt(lr$chisq), hr = exp(cox$coefficients), sehr = sqrt(diag(cox$var)))
  return(y)
}
wlr.Stat <- function(survival, cnsr, trt, stra = NULL, fparam) {
  if (length(fparam$rho)!=length(fparam$gamma)){
    stop("rho and gamma have to be of the same length")
  }
  if (is.null(stra)){stra=1}
  stralvl <- unique(stra)
  r<-NULL   # to hold the final statistics for each strata 
  for (i in 1:length(stralvl)) {
    d <- data.table(survival = survival, cnsr = cnsr, trt = trt, stra=stra)
    d <- d[stra==stralvl[i]]
    x <- ten(survfit(Surv(survival, 1 - cnsr) ~ trt, data = d))
    if (!attr(x, "sorted")=="t") setkey(x, t)
    t1 <- x[e > 0, t, by = t][, t]
    
    FHn <- paste("FH(", fparam$rho, ",", fparam$gamma,")", sep="")
    
    n1 <- c(FHn)
    
    if (!is.null(fparam$stdset)){
      n1 <- c(n1, c("1", "n", "sqrtN", "S1", "S2"))
    }
    
    if (!is.null(fparam$APPLE)){
      n1 <-c(n1, "APPLE")
    }
    wt <- data.table(array(data = 1, dim = c(length(t1), length(n1))))
    
    if (!is.null(fparam$wlr)){
      if (!fparam$wlr %in% n1){
        stop("fparam$wlr value is invalid. Refer to the help document for a list of allowed values.")
      }
    }
    
    data.table::setnames(wt, n1)
    
    
    if (!is.null(fparam$stdset)){
      ## Gehan-Breslow generalized Wilcoxon, weight = n
      data.table::set(wt, j = "n", value = x[e > 0, max(n), by = t][, V1])
      ## Tarone-Ware, weight = sqrt(n)
      data.table::set(wt, j = "sqrtN", value = wt[, sqrt(.SD), .SDcols = "n"])
      ## Peto-Peto, weight = S(t) = modified estimator of survival function
      data.table::set(wt, j = "S1", value = cumprod(x[e > 0, 1 - sum(e)/(max(n) + 1), by = t][, V1]))
      ## modified Peto-Peto (by Andersen), weight = S(t)n / n+1
      data.table::set(wt, j = "S2", value = wt[, S1] * x[e > 0, max(n)/(max(n) + 1), by = t][, V1])
    }
    
    ## Fleming-Harrington
    S3 <- sf(x = x[e > 0, sum(e), by = t][, V1], n = x[e > 0, max(n), by = t][, V1], what = "S")
    S3 <- c(1, S3[seq.int(length(S3) - 1L)])
    wt[, (FHn) := mapply(function(p, q) S3^p * ((1 - S3)^q), fparam$rho, fparam$gamma, SIMPLIFY=FALSE)]
    
    if (!is.null(fparam$APPLE)){
      ## simplified APPLE, w1=0 and w2=1, separate at delayed separation point
      data.table::set(wt, j = "APPLE", value = x[e > 0, ifelse(t < fparam$APPLE, 0, 1), by = t][, V1])
    }
    
    n2 <- c("W", "Q", "Var", "Z", "pNorm", "chiSq", "df", "pChisq")
    res <- data.table(matrix(0, nrow = ncol(wt), ncol = length(n2)))
    setnames(res, n2)
    set(res, j = 1L, value = n1)
    predict(x)
    ## events minus predicted
    eMP1 <- attr(x, "pred")
    eMP1 <- eMP1[rowSums(eMP1) > 0, ]
    ## covariance
    COV(x)
    cov1 <- attr(x, "COV")
    if (is.null(dim(cov1))) {
      cov1 <- cov1[names(cov1) %in% t1]
    } else {
      ## 3rd dimension = times
      cov1 <- cov1[, , dimnames(cov1)[[3]] %in% t1]
    }
    eMP1 <- unlist(eMP1[, .SD, .SDcols = (length(eMP1) - 1L)])
    data.table::set(res, j = "Q", value = colSums(wt * eMP1))
    data.table::set(res, j = "Var", value = colSums(wt^2 * cov1))
    r<-rbind(r,res)
  }  
  res<- r[,.(Q=sum(Q),Var=sum(Var)),by=W]
  res[, `:=`("Z", Q/sqrt(Var))]
  res[, `:=`("pNorm", 2 * (1 - stats::pnorm(abs(Z))))]
  res[, `:=`("chiSq", Q^2/Var)]
  res[, `:=`("df", 1)]
  res[, `:=`("pChisq", 1 - stats::pchisq(chiSq, df))]
  res[, `:=`("onesidedp", ifelse(Z < 0, pNorm/2, (1 - pNorm/2)))]
  
  pvals <- transpose(res[, .(onesidedp)])
  setnames(pvals, paste0("pval_", n1))
  if (!is.null(fparam$wlr)){
    pval = res[W == fparam$wlr, onesidedp]
    pvals <-cbind(pval, pvals)
  }
  y <- cbind(pvals)
  
  return(y)
}

simulatedTrials = 10000
delays = c(0,1,2,3,4)

reject_rmst_minimax_event = mat.or.vec(length(delays),simulatedTrials)
reject_rmst_minimax_observed = mat.or.vec(length(delays),simulatedTrials)
reject_lr = mat.or.vec(length(delays),simulatedTrials)
reject_wlr_rho00_gamma1 = mat.or.vec(length(delays),simulatedTrials)
t_cut_event =  mat.or.vec(length(delays),simulatedTrials)
t_cut_observed =  mat.or.vec(length(delays),simulatedTrials)

medC = 6 #Median survival of the control group
N = 75 # Sample size
E = 52 #Number of events
gamma <- 10 ## enrollment rate

if(N %% 2 == 0){
  N=N
}else{
  N=N+1
}

etaC = 0.01 #Dropout rate control group
etaE = 0.01 #Dropout rate experimental group

for(d in 1:length(delays)){
  
  for(k in 1:simulatedTrials){
    
    if(delays[d]==0){
      hr = 0.4 #Hazard ratio without delay
      intervals = NULL
    }else{
      hr <- c(1,0.4) #Hazard ratio with delay
      intervals <- delays[d]
    }
    
    #Simulation of a single trial
    
    sim1 = nphsim(nsim=1,lambdaC=log(2)/medC,lambdaE=log(2)/medC*hr, ssC=N/2,ssE=N/2,
                  intervals=intervals,E=E,gamma=gamma,etaC = etaC, etaE = etaE)
                  
    #Save results such us p-values, the t^* (see paper), the HR, adjusted HR, RMST ratio.
    
    t_cut_event[d,k] = sim1$minimax_event
    t_cut_observed[d,k] = sim1$minimax_observed
    
    reject_lr[d,k] = ifelse(sim1$pval_lr < 0.025, 1, 0)
    reject_rmst_minimax_event[d,k] = ifelse(sim1$pval_rmst_event$pval < 0.025, 1, 0)
    reject_rmst_minimax_observed[d,k] = ifelse(sim1$pval_rmst_observed$pval < 0.025, 1, 0)
    reject_wlr_rho00_gamma1[d,k] = ifelse(sim1$pval_wlr$`pval_FH(0,1)` < 0.025, 1, 0)
    
    cat("Delay",delays[d],", Completion:",k/simulatedTrials*100,"%","\n")
    
  }
  
  
}
